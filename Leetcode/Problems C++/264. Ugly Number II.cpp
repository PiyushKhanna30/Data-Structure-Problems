class Solution {
public:
    int nthUglyNumber(int n) {
        if(n==0)
            return 0;
        vector<int>dp(n);//size n+1 
        dp[0]=1;
        int t2=0,t3=0,t5=0;    //  counter for 2,3,5
        for(int i=1;i<n;i++)
        {
            dp[i]=min(dp[t2]*2,min(dp[t3]*3,dp[t5]*5));
            if(dp[i]==dp[t2]*2)
            {
                t2++;
            }
            if(dp[i]==dp[t3]*3)
            {
                t3++;
            }
            if(dp[i]==dp[t5]*5)
            {
                t5++;
            }
        }
        return dp[n-1];
    }
};
/*
NAIVE SOLUTION - CHECK EACH NUMBER IfUgly
-----------------------------------------
class Solution {
public:
    int maxDivisible(long num,int x)          
    {
        while(num%x==0)
        {
            num=num/x;
        }
        return num;
    }
    bool isUgly(long num)
    {
        num=maxDivisible(num,2);
        num=maxDivisible(num,3);
        num=maxDivisible(num,5);
        return (num==1)?true:false;         //eg 10%2==0  ->  10/2  ->  5%2!=0  ->  5%3!=0   ->  5%5==0  -> 1
    }
    int nthUglyNumber(int n) {
        int x=n;
        long num=1;
        while(x)
        {
            if(isUgly(num))
            {
                x--;
                if(x==0)
                    return num;
            }
            num++;
        }
        return 0;
    }
};
*/

/*
DP
The key is to realize each number can be and have to be generated by a former number multiplied by 2, 3 or 5
e.g.
1 2 3 4 5 6 8 9 10 12 15..
what is next?
it must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number.

How do we determine x, y, z then?
apparently, you can just traverse the sequence generated by far from 1 ... 15, until you find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x=8, y=6, z=4. Then you compare x * 2, y * 3, z * 5 so you know next number will be x * 2 = 8 * 2 = 16.
k, now you have 1,2,3,4,....,15, 16,

Then what is next?
You wanna do the same process again to find the new x, y, z, but you realize, wait, do I have to
traverse the sequence generated by far again?

NO! since you know last time, x=8, y=6, z=4 and x=8 was used to generate 16, so this time, you can immediately know the new_x = 9 (the next number after 8 is 9 in the generated sequence), y=6, z=4.
Then you need to compare new_x * 2, y * 3, z * 5. You know next number is 9 * 2 = 18;

And you also know, the next x will be 10 since new_x = 9 was used this time.
But what is next y? apparently, if y=6, 6*3 = 18, which is already generated in this round. So you also need to update next y from 6 to 8.

Based on the idea above, you can actually generated x,y,z from very beginning, and update x, y, z accordingly. It ends up with a O(n) solution.
*/